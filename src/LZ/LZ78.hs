module LZ.LZ78 where

import System.IO
import Data.Map as M
import Prelude as P

compress :: String -> [(Int, Char)]
compress = compress' . textWithSpace
  where
    textWithSpace = (++ " ")
    singleton x y = M.singleton x y
    member x y = M.member x y
    insert x y z = M.insert x y z
    size = M.size


compress' :: String -> [(Int, Char)]
compress' = reverse . third . P.foldl step (singleton "" 0, "", [])
  where 
    -- Ajouter un espace à la fin de la chaîne
    textWithSpace = (++ " ")
    step (dict, pat, log) char =
          let pat' = char:pat
          in if member pat' dict
            -- `pat'` is already in our dictionary, so
            -- we've previously extended `pat` by `char`, and 
            -- we don't need to record anything
            then (dict, pat', log)
            -- pat' is new to us, so 
            --  * assign it a new id in the dictionary 
            --  * start reading a new pattern
            --  * record it in the log
            else (insert pat' (size dict) dict, "", (dict ! pat, char):log)
    third (_, _, log) = log
-- Function to decompress a list of codes generated by LZ78
uncompress :: [(Int, Char)] -> String
uncompress [] = ""
uncompress codes = helper [] codes
  where
    helper _ [] = ""
    helper dict ((index, char):rest) =
      let entry = case index of
                    0 -> [char]
                    _ -> let (prefix, _) = dict !! (index - 1)
                         in prefix ++ [char]
          newDict = dict ++ [(entry ++ [char], length dict + 1)]
      in entry ++ helper newDict rest